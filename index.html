<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>ì •ìš°ì˜ í¬ì¼“ëª¬ RPG</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        body { font-family: 'Malgun Gothic', sans-serif; background: #000; overflow: hidden; position: fixed; width: 100%; height: 100%; }
        #gameCanvas { display: block; background: #88c070; touch-action: none; image-rendering: pixelated; }
        
        .hud { position: absolute; top: 10px; left: 10px; right: 10px; display: none; justify-content: space-between; pointer-events: none; z-index: 10; }
        .hud.active { display: flex; }
        .hud-box { background: linear-gradient(180deg, rgba(40,40,60,0.95), rgba(20,20,40,0.95)); padding: 10px 14px; border-radius: 12px; border: 2px solid #ffd700; color: white; font-size: 12px; font-weight: bold; box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
        .pokemon-info { display: flex; align-items: center; gap: 10px; }
        .pokemon-icon { width: 40px; height: 40px; border-radius: 50%; border: 2px solid #ffd700; object-fit: contain; background: rgba(255,255,255,0.1); }
        .pokemon-name { color: #ffd700; font-size: 14px; }
        .level-badge { background: linear-gradient(135deg, #e74c3c, #c0392b); padding: 2px 8px; border-radius: 10px; font-size: 10px; margin-left: 5px; }
        .bar { height: 12px; background: #333; border-radius: 6px; overflow: hidden; margin-top: 3px; width: 100px; }
        .bar-fill { height: 100%; transition: width 0.3s; }
        .hp-fill { background: linear-gradient(90deg, #4CAF50, #8BC34A); }
        .hp-fill.low { background: linear-gradient(90deg, #ff6b6b, #ee5a6f); }
        .exp-fill { background: linear-gradient(90deg, #3498db, #2980b9); }
        .bar-label { font-size: 9px; display: flex; justify-content: space-between; }
        
        .joystick-container { position: absolute; bottom: 30px; left: 30px; width: 120px; height: 120px; z-index: 100; display: none; }
        .joystick-container.active { display: block; }
        .joystick-base { width: 100%; height: 100%; background: radial-gradient(circle, rgba(60,60,80,0.9), rgba(30,30,50,0.95)); border-radius: 50%; border: 4px solid rgba(255,215,0,0.5); box-shadow: 0 0 20px rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; position: relative; }
        .joystick-stick { width: 50px; height: 50px; background: radial-gradient(circle at 30% 30%, #888, #444); border-radius: 50%; border: 3px solid #666; box-shadow: 0 4px 10px rgba(0,0,0,0.5); position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); }
        
        /* ìˆ˜ì •ëœ ì•¡ì…˜ ë²„íŠ¼ - í™”ë©´ ì•ˆì— ë§ê²Œ ë°°ì¹˜ */
        .action-buttons { position: absolute; bottom: 20px; right: 15px; display: none; z-index: 100; width: 140px; height: 140px; }
        .action-buttons.active { display: block; }
        .action-btn { width: 55px; height: 55px; border-radius: 50%; border: 3px solid rgba(255,255,255,0.3); display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 20px; color: white; cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.4); position: absolute; }
        .action-btn:active { transform: scale(0.9); }
        .action-btn .label { font-size: 8px; }
        .btn-attack { background: linear-gradient(135deg, #e74c3c, #c0392b); bottom: 0; right: 0; }
        .btn-skill1 { background: linear-gradient(135deg, #3498db, #2980b9); bottom: 0; left: 0; }
        .btn-skill2 { background: linear-gradient(135deg, #9b59b6, #8e44ad); top: 0; right: 0; }
        .btn-dash { background: linear-gradient(135deg, #2ecc71, #27ae60); top: 0; left: 0; width: 50px; height: 50px; font-size: 18px; }
        .cooldown { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); border-radius: 50%; display: none; align-items: center; justify-content: center; font-size: 12px; }
        .cooldown.show { display: flex; }
        
        .menu-btn { position: absolute; top: 10px; right: 10px; width: 40px; height: 40px; background: rgba(40,40,60,0.9); border: 2px solid #ffd700; border-radius: 10px; display: none; align-items: center; justify-content: center; font-size: 20px; cursor: pointer; z-index: 100; }
        .menu-btn.active { display: flex; }
        
        .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 200; overflow-y: auto; padding: 20px; }
        .screen.active { display: flex; }
        
        /* ë°ì€ ì‹œì‘ í™”ë©´ ë””ìì¸ */
        #startScreen { 
            background: linear-gradient(135deg, #74ebd5 0%, #ACB6E5 50%, #86A8E7 100%); 
            justify-content: flex-start; 
            padding-top: 30px; 
        }
        .game-title { 
            font-size: 1.8em; 
            color: #2c3e50; 
            text-shadow: 2px 2px 4px rgba(255,255,255,0.5); 
            margin-bottom: 5px; 
            background: linear-gradient(135deg, #f39c12, #e74c3c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: bold;
        }
        .game-subtitle { 
            color: #34495e; 
            font-size: 12px; 
            margin-bottom: 15px; 
            font-weight: bold;
        }
        
        .pokemon-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; max-width: 350px; width: 100%; }
        .pokemon-card { 
            background: rgba(255,255,255,0.85); 
            border-radius: 15px; 
            padding: 12px; 
            text-align: center; 
            cursor: pointer; 
            border: 3px solid transparent; 
            transition: all 0.2s; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        .pokemon-card:hover, .pokemon-card.selected { 
            background: rgba(255,255,255,1); 
            border-color: #f39c12; 
            transform: translateY(-5px); 
            box-shadow: 0 8px 25px rgba(243,156,18,0.3);
        }
        .pokemon-card img { width: 60px; height: 60px; object-fit: contain; }
        .pokemon-card .name { color: #2c3e50; font-weight: bold; font-size: 13px; margin-top: 5px; }
        .pokemon-card .type { color: #e74c3c; font-size: 11px; font-weight: bold; }
        
        .start-btn { 
            margin-top: 20px; 
            padding: 14px 45px; 
            font-size: 1.1em; 
            font-weight: bold; 
            background: linear-gradient(135deg, #f39c12, #e74c3c); 
            color: white; 
            border: none; 
            border-radius: 30px; 
            cursor: pointer; 
            box-shadow: 0 6px 20px rgba(243,156,18,0.4);
            transition: all 0.2s;
        }
        .start-btn:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(243,156,18,0.5);
        }
        .start-btn:disabled { background: #bdc3c7; cursor: not-allowed; box-shadow: none; }
        
        #gameOverScreen, #pauseScreen { background: rgba(0,0,0,0.92); }
        .popup-box { background: linear-gradient(180deg, rgba(40,40,60,0.98), rgba(20,20,40,0.98)); border: 3px solid #ffd700; border-radius: 20px; padding: 25px 35px; text-align: center; max-width: 320px; }
        .popup-title { font-size: 1.8em; margin-bottom: 15px; }
        .popup-title.gameover { color: #e74c3c; }
        .popup-title.pause { color: #ffd700; }
        .popup-stats { display: flex; flex-direction: column; gap: 8px; margin-bottom: 20px; }
        .popup-stat { display: flex; justify-content: space-between; color: white; font-size: 13px; padding: 8px 12px; background: rgba(255,255,255,0.1); border-radius: 8px; }
        .popup-stat .value { color: #ffd700; font-weight: bold; }
        .popup-buttons { display: flex; flex-direction: column; gap: 10px; }
        .popup-btn { padding: 12px 25px; font-size: 1em; font-weight: bold; border: none; border-radius: 20px; cursor: pointer; }
        .btn-primary { background: linear-gradient(135deg, #4CAF50, #45B649); color: white; }
        .btn-secondary { background: linear-gradient(135deg, #3498db, #2980b9); color: white; }
        .btn-danger { background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; }
        
        .levelup { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #ffd700, #ffb700); color: #000; padding: 15px 30px; border-radius: 15px; font-size: 1.3em; font-weight: bold; z-index: 150; display: none; animation: pop 0.5s ease-out; }
        .levelup.show { display: block; }
        @keyframes pop { 0% { transform: translate(-50%, -50%) scale(0); } 50% { transform: translate(-50%, -50%) scale(1.2); } 100% { transform: translate(-50%, -50%) scale(1); } }
        
        .boss-hp { position: absolute; bottom: 160px; left: 50%; transform: translateX(-50%); width: 70%; max-width: 350px; display: none; z-index: 80; }
        .boss-hp.active { display: block; }
        .boss-name { color: #ff6b6b; font-size: 13px; font-weight: bold; text-align: center; margin-bottom: 5px; text-shadow: 2px 2px 4px #000; }
        .boss-bar { height: 16px; background: #333; border-radius: 8px; border: 2px solid #ff6b6b; overflow: hidden; }
        .boss-bar-fill { height: 100%; background: linear-gradient(90deg, #ff6b6b, #e74c3c); transition: width 0.3s; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div class="hud" id="hud">
        <div class="hud-box">
            <div class="pokemon-info">
                <img class="pokemon-icon" id="pokemonIcon" src="">
                <div>
                    <div><span class="pokemon-name" id="pokemonName">í”¼ì¹´ì¸„</span><span class="level-badge">Lv.<span id="levelNum">1</span></span></div>
                    <div class="bar-label"><span>HP</span><span id="hpText">100/100</span></div>
                    <div class="bar"><div class="bar-fill hp-fill" id="hpFill" style="width:100%"></div></div>
                    <div class="bar-label"><span>EXP</span><span id="expText">0/100</span></div>
                    <div class="bar"><div class="bar-fill exp-fill" id="expFill" style="width:0%"></div></div>
                </div>
            </div>
        </div>
        <div class="hud-box">
            <div>ğŸŒŠ ì›¨ì´ë¸Œ: <span id="waveNum">1</span></div>
            <div>ğŸ’€ ì²˜ì¹˜: <span id="killCount">0</span></div>
            <div style="margin-top:5px;">âš”ï¸<span id="atkStat">10</span> ğŸ›¡ï¸<span id="defStat">5</span></div>
        </div>
    </div>
    
    <div class="menu-btn" id="menuBtn">â˜°</div>
    
    <div class="joystick-container" id="joystickContainer">
        <div class="joystick-base" id="joystickBase">
            <div class="joystick-stick" id="joystickStick"></div>
        </div>
    </div>
    
    <div class="action-buttons" id="actionButtons">
        <div class="action-btn btn-dash" id="btnDash"><span>ğŸ’¨</span><div class="cooldown" id="dashCD"></div></div>
        <div class="action-btn btn-skill2" id="btnSkill2"><span>ğŸ’¥</span><span class="label">í•„ì‚´</span><div class="cooldown" id="skill2CD"></div></div>
        <div class="action-btn btn-skill1" id="btnSkill1"><span>âœ¨</span><span class="label">ìŠ¤í‚¬</span><div class="cooldown" id="skill1CD"></div></div>
        <div class="action-btn btn-attack" id="btnAttack"><span>âš¡</span><span class="label">ê³µê²©</span></div>
    </div>
    
    <div class="boss-hp" id="bossHp">
        <div class="boss-name" id="bossName">ğŸ‘‘ ë³´ìŠ¤</div>
        <div class="boss-bar"><div class="boss-bar-fill" id="bossHpFill" style="width:100%"></div></div>
    </div>
    
    <div class="levelup" id="levelup">â¬†ï¸ LEVEL UP!</div>
    
    <div class="screen active" id="startScreen">
        <div class="game-title">ğŸ® ì •ìš°ì˜ í¬ì¼“ëª¬ RPG</div>
        <div class="game-subtitle">Pokemon Roguelike Adventure</div>
        <div class="pokemon-grid" id="pokemonGrid"></div>
        <button class="start-btn" id="startBtn" disabled>í¬ì¼“ëª¬ì„ ì„ íƒí•˜ì„¸ìš”</button>
    </div>
    
    <div class="screen" id="pauseScreen">
        <div class="popup-box">
            <div class="popup-title pause">â¸ï¸ ì¼ì‹œì •ì§€</div>
            <div class="popup-stats">
                <div class="popup-stat"><span>ë ˆë²¨</span><span class="value" id="pauseLevel">1</span></div>
                <div class="popup-stat"><span>ì›¨ì´ë¸Œ</span><span class="value" id="pauseWave">1</span></div>
                <div class="popup-stat"><span>ì²˜ì¹˜</span><span class="value" id="pauseKills">0</span></div>
            </div>
            <div class="popup-buttons">
                <button class="popup-btn btn-primary" id="resumeBtn">â–¶ï¸ ê³„ì†í•˜ê¸°</button>
                <button class="popup-btn btn-secondary" id="changeCharBtn">ğŸ”„ ìºë¦­í„° ë³€ê²½</button>
                <button class="popup-btn btn-danger" id="exitBtn">ğŸšª ë‚˜ê°€ê¸°</button>
            </div>
        </div>
    </div>
    
    <div class="screen" id="gameOverScreen">
        <div class="popup-box">
            <div class="popup-title gameover">ğŸ’€ ê²Œì„ ì˜¤ë²„</div>
            <div class="popup-stats">
                <div class="popup-stat"><span>ìµœì¢… ë ˆë²¨</span><span class="value" id="finalLevel">1</span></div>
                <div class="popup-stat"><span>ìµœì¢… ì›¨ì´ë¸Œ</span><span class="value" id="finalWave">1</span></div>
                <div class="popup-stat"><span>ì´ ì²˜ì¹˜</span><span class="value" id="finalKills">0</span></div>
            </div>
            <div class="popup-buttons">
                <button class="popup-btn btn-primary" id="restartBtn">ğŸ”„ ë‹¤ì‹œ ì‹œì‘</button>
                <button class="popup-btn btn-secondary" id="changeCharBtn2">ğŸ­ ìºë¦­í„° ë³€ê²½</button>
                <button class="popup-btn btn-danger" id="exitBtn2">ğŸšª ë‚˜ê°€ê¸°</button>
            </div>
        </div>
    </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const MAP = { width: 2000, height: 2000, tileSize: 32 };

const POKEMON = {
    pikachu: { id: 25, name: 'í”¼ì¹´ì¸„', type: 'ì „ê¸°', hp: 100, atk: 15, def: 8, spd: 5, color: '#f1c40f' },
    charmander: { id: 4, name: 'íŒŒì´ë¦¬', type: 'ë¶ˆê½ƒ', hp: 90, atk: 18, def: 6, spd: 4.5, color: '#e74c3c' },
    squirtle: { id: 7, name: 'ê¼¬ë¶€ê¸°', type: 'ë¬¼', hp: 130, atk: 12, def: 12, spd: 3.8, color: '#3498db' },
    bulbasaur: { id: 1, name: 'ì´ìƒí•´ì”¨', type: 'í’€', hp: 115, atk: 14, def: 10, spd: 4, color: '#2ecc71' },
    eevee: { id: 133, name: 'ì´ë¸Œì´', type: 'ë…¸ë§', hp: 105, atk: 14, def: 9, spd: 5.5, color: '#c8a87c' },
    gengar: { id: 94, name: 'íŒ¬í…€', type: 'ê³ ìŠ¤íŠ¸', hp: 85, atk: 20, def: 5, spd: 6, color: '#9b59b6' }
};

const ENEMIES = {
    rattata: { id: 19, name: 'ê¼¬ë ›', hp: 40, atk: 6, def: 2, spd: 2.5, exp: 15 },
    pidgey: { id: 16, name: 'êµ¬êµ¬', hp: 45, atk: 7, def: 3, spd: 3, exp: 18 },
    zubat: { id: 41, name: 'ì£¼ë±ƒ', hp: 50, atk: 8, def: 3, spd: 3.5, exp: 22 },
    geodude: { id: 74, name: 'ê¼¬ë§ˆëŒ', hp: 80, atk: 12, def: 8, spd: 1.5, exp: 30 },
    machop: { id: 66, name: 'ì•Œí†µëª¬', hp: 70, atk: 15, def: 5, spd: 2, exp: 35 },
    gastly: { id: 92, name: 'ê³ ì˜¤ìŠ¤', hp: 35, atk: 18, def: 2, spd: 4, exp: 40 }
};

const BOSSES = {
    onix: { id: 95, name: 'ë¡±ìŠ¤í†¤', hp: 500, atk: 25, def: 15, spd: 1.5, exp: 200 },
    arbok: { id: 24, name: 'ì•„ë³´í¬', hp: 400, atk: 30, def: 10, spd: 2.5, exp: 250 },
    nidoking: { id: 34, name: 'ë‹ˆë“œí‚¹', hp: 600, atk: 35, def: 12, spd: 2, exp: 350 }
};

let gameState = 'menu';
let selectedPokemon = null;
let player = null;
let enemies = [];
let projectiles = [];
let particles = [];
let items = [];
let boss = null;
let wave = 1, kills = 0, totalExp = 0;
let camera = { x: 0, y: 0 };
let imageCache = {};

// ìˆ˜ì •ëœ ì…ë ¥ ìƒíƒœ - í‚¤ë³´ë“œìš© ë³„ë„ ë³€ìˆ˜
let input = { moveX: 0, moveY: 0, attack: false, skill1: false, skill2: false, dash: false };
let keyState = { up: false, down: false, left: false, right: false };
let joystick = { active: false, baseX: 0, baseY: 0, touchId: null };
let cooldowns = { attack: 0, skill1: 0, skill2: 0, dash: 0 };

function getSprite(id, type) {
    const base = 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon';
    return type === 'back' ? `${base}/back/${id}.png` : `${base}/${id}.png`;
}

function loadImage(src) {
    return new Promise(resolve => {
        if (imageCache[src]) return resolve(imageCache[src]);
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => { imageCache[src] = img; resolve(img); };
        img.onerror = () => resolve(null);
        img.src = src;
    });
}

async function preloadImages() {
    const urls = [];
    Object.values(POKEMON).forEach(p => { urls.push(getSprite(p.id, 'front'), getSprite(p.id, 'back')); });
    Object.values(ENEMIES).forEach(e => { urls.push(getSprite(e.id, 'front'), getSprite(e.id, 'back')); });
    Object.values(BOSSES).forEach(b => { urls.push(getSprite(b.id, 'front'), getSprite(b.id, 'back')); });
    await Promise.all(urls.map(loadImage));
}

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}

function initPokemonSelection() {
    const grid = document.getElementById('pokemonGrid');
    grid.innerHTML = '';
    Object.entries(POKEMON).forEach(([key, p]) => {
        const card = document.createElement('div');
        card.className = 'pokemon-card';
        card.innerHTML = `<img src="${getSprite(p.id)}"><div class="name">${p.name}</div><div class="type">${p.type}</div>`;
        card.onclick = () => {
            document.querySelectorAll('.pokemon-card').forEach(c => c.classList.remove('selected'));
            card.classList.add('selected');
            selectedPokemon = key;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('startBtn').textContent = 'ğŸ® ëª¨í—˜ ì‹œì‘!';
        };
        grid.appendChild(card);
    });
}

function showUI(show) {
    document.getElementById('startScreen').classList.toggle('active', !show);
    document.getElementById('hud').classList.toggle('active', show);
    document.getElementById('joystickContainer').classList.toggle('active', show);
    document.getElementById('actionButtons').classList.toggle('active', show);
    document.getElementById('menuBtn').classList.toggle('active', show);
    document.getElementById('gameOverScreen').classList.remove('active');
    document.getElementById('pauseScreen').classList.remove('active');
}

function startGame() {
    if (!selectedPokemon) return;
    const data = POKEMON[selectedPokemon];
    
    player = {
        x: MAP.width / 2, y: MAP.height / 2,
        width: 64, height: 64,
        hp: data.hp, maxHp: data.hp,
        atk: data.atk, def: data.def, spd: data.spd,
        level: 1, exp: 0, expToNext: 100,
        direction: 'down', pokemonId: data.id,
        name: data.name, color: data.color,
        invulnerable: 0, isDashing: false, dashTime: 0
    };
    
    enemies = []; projectiles = []; particles = []; items = []; boss = null;
    wave = 1; kills = 0; totalExp = 0;
    cooldowns = { attack: 0, skill1: 0, skill2: 0, dash: 0 };
    keyState = { up: false, down: false, left: false, right: false };
    input = { moveX: 0, moveY: 0, attack: false, skill1: false, skill2: false, dash: false };
    
    gameState = 'playing';
    showUI(true);
    updateHUD();
    spawnWave();
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
}

function spawnWave() {
    if (wave % 5 === 0) {
        spawnBoss();
        return;
    }
    
    const count = Math.min(5 + wave * 2, 20);
    const keys = Object.keys(ENEMIES);
    const mult = 1 + (wave - 1) * 0.15;
    
    for (let i = 0; i < count; i++) {
        setTimeout(() => {
            if (gameState !== 'playing') return;
            const key = keys[Math.floor(Math.random() * Math.min(2 + Math.floor(wave/2), keys.length))];
            const data = ENEMIES[key];
            
            let x, y;
            do {
                const edge = Math.floor(Math.random() * 4);
                if (edge === 0) { x = Math.random() * MAP.width; y = camera.y - 50; }
                else if (edge === 1) { x = Math.random() * MAP.width; y = camera.y + canvas.height + 50; }
                else if (edge === 2) { x = camera.x - 50; y = Math.random() * MAP.height; }
                else { x = camera.x + canvas.width + 50; y = Math.random() * MAP.height; }
                x = Math.max(50, Math.min(MAP.width - 50, x));
                y = Math.max(50, Math.min(MAP.height - 50, y));
            } while (Math.hypot(x - player.x, y - player.y) < 150);
            
            enemies.push({
                x, y, width: 48, height: 48,
                hp: Math.floor(data.hp * mult), maxHp: Math.floor(data.hp * mult),
                atk: Math.floor(data.atk * mult), def: data.def,
                spd: data.spd + wave * 0.05, exp: Math.floor(data.exp * mult),
                pokemonId: data.id, name: data.name, direction: 'down',
                attackCooldown: 0, hitFlash: 0
            });
        }, i * 400);
    }
}

function spawnBoss() {
    const keys = Object.keys(BOSSES);
    const key = keys[Math.floor((wave / 5 - 1) % keys.length)];
    const data = BOSSES[key];
    const mult = 1 + Math.floor(wave / 5) * 0.3;
    
    boss = {
        x: MAP.width / 2, y: MAP.height / 2 - 200,
        width: 96, height: 96,
        hp: Math.floor(data.hp * mult), maxHp: Math.floor(data.hp * mult),
        atk: Math.floor(data.atk * mult), def: data.def,
        spd: data.spd, exp: Math.floor(data.exp * mult),
        pokemonId: data.id, name: data.name, direction: 'down',
        attackCooldown: 0, hitFlash: 0, specialCooldown: 120
    };
    
    document.getElementById('bossHp').classList.add('active');
    document.getElementById('bossName').textContent = `ğŸ‘‘ ${boss.name}`;
    updateBossHP();
}

function updateBossHP() {
    if (!boss) return;
    const pct = Math.max(0, boss.hp / boss.maxHp * 100);
    document.getElementById('bossHpFill').style.width = pct + '%';
}

function checkWaveComplete() {
    if (enemies.length === 0 && !boss) {
        wave++;
        player.hp = Math.min(player.maxHp, player.hp + Math.floor(player.maxHp * 0.1));
        setTimeout(() => { if (gameState === 'playing') spawnWave(); }, 2000);
    }
}

// ìˆ˜ì •ëœ í‚¤ë³´ë“œ ì…ë ¥ ì²˜ë¦¬
function updateKeyboardInput() {
    let kx = 0, ky = 0;
    if (keyState.left) kx -= 1;
    if (keyState.right) kx += 1;
    if (keyState.up) ky -= 1;
    if (keyState.down) ky += 1;
    
    // ì¡°ì´ìŠ¤í‹±ì´ í™œì„±í™”ë˜ì–´ ìˆì§€ ì•Šì„ ë•Œë§Œ í‚¤ë³´ë“œ ì…ë ¥ ì ìš©
    if (!joystick.active) {
        input.moveX = kx;
        input.moveY = ky;
    }
}

function updatePlayer(dt) {
    if (gameState !== 'playing') return;
    
    // í‚¤ë³´ë“œ ì…ë ¥ ì—…ë°ì´íŠ¸
    updateKeyboardInput();
    
    if (player.isDashing) {
        player.dashTime -= dt;
        if (player.dashTime <= 0) player.isDashing = false;
    }
    
    let mx = input.moveX, my = input.moveY;
    if (mx !== 0 || my !== 0) {
        const len = Math.hypot(mx, my);
        if (len > 0) { mx /= len; my /= len; }
        
        // ìˆ˜ì •ëœ ë°©í–¥ ì„¤ì • - ì´ë™ ë°©í–¥ê³¼ ì¼ì¹˜í•˜ë„ë¡
        if (Math.abs(mx) > Math.abs(my)) {
            player.direction = mx < 0 ? 'left' : 'right';  // ìˆ˜ì •: ë¶€í˜¸ ë°˜ëŒ€ë¡œ
        } else {
            player.direction = my < 0 ? 'up' : 'down';  // ìˆ˜ì •: ë¶€í˜¸ ë°˜ëŒ€ë¡œ
        }
        
        const speed = player.isDashing ? player.spd * 3 : player.spd;
        player.x += mx * speed * dt * 60;
        player.y += my * speed * dt * 60;
    }
    
    player.x = Math.max(player.width/2, Math.min(MAP.width - player.width/2, player.x));
    player.y = Math.max(player.height/2, Math.min(MAP.height - player.height/2, player.y));
    
    if (player.invulnerable > 0) player.invulnerable -= dt * 60;
    
    Object.keys(cooldowns).forEach(k => { if (cooldowns[k] > 0) cooldowns[k] -= dt * 60; });
    
    if (input.attack && cooldowns.attack <= 0) {
        fireAttack();
        cooldowns.attack = 12;
    }
    if (input.skill1 && cooldowns.skill1 <= 0) {
        fireSkill1();
        cooldowns.skill1 = 180;
    }
    if (input.skill2 && cooldowns.skill2 <= 0) {
        fireSkill2();
        cooldowns.skill2 = 480;
    }
    if (input.dash && cooldowns.dash <= 0 && !player.isDashing) {
        player.isDashing = true;
        player.dashTime = 0.15;
        player.invulnerable = Math.max(player.invulnerable, 15);
        cooldowns.dash = 90;
        for (let i = 0; i < 8; i++) {
            particles.push({ x: player.x, y: player.y, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4, life: 15, color: player.color, size: 5 });
        }
    }
    
    updateCooldownUI();
}

function getDir() {
    const dirs = { up: {x:0,y:-1}, down: {x:0,y:1}, left: {x:-1,y:0}, right: {x:1,y:0} };
    return dirs[player.direction];
}

function fireAttack() {
    const d = getDir();
    projectiles.push({
        x: player.x + d.x * 30, y: player.y + d.y * 30,
        vx: d.x * 12, vy: d.y * 12,
        damage: player.atk, size: 10, color: player.color,
        owner: 'player', life: 60
    });
    for (let i = 0; i < 4; i++) {
        particles.push({ x: player.x + d.x*20, y: player.y + d.y*20, vx: d.x*2+(Math.random()-0.5)*2, vy: d.y*2+(Math.random()-0.5)*2, life: 10, color: player.color, size: 3 });
    }
}

function fireSkill1() {
    for (let i = 0; i < 8; i++) {
        const ang = (i/8) * Math.PI * 2;
        projectiles.push({
            x: player.x, y: player.y,
            vx: Math.cos(ang) * 8, vy: Math.sin(ang) * 8,
            damage: Math.floor(player.atk * 1.5), size: 12, color: '#3498db',
            owner: 'player', life: 60
        });
    }
    for (let i = 0; i < 12; i++) {
        particles.push({ x: player.x, y: player.y, vx: (Math.random()-0.5)*6, vy: (Math.random()-0.5)*6, life: 20, color: '#3498db', size: 5 });
    }
}

function fireSkill2() {
    const radius = 150;
    enemies.forEach(e => {
        if (Math.hypot(e.x - player.x, e.y - player.y) < radius) {
            damageEnemy(e, Math.floor(player.atk * 3));
        }
    });
    if (boss && Math.hypot(boss.x - player.x, boss.y - player.y) < radius) {
        damageBoss(Math.floor(player.atk * 3));
    }
    for (let i = 0; i < 30; i++) {
        const ang = (i/30) * Math.PI * 2;
        const dist = Math.random() * radius;
        particles.push({ x: player.x + Math.cos(ang)*dist, y: player.y + Math.sin(ang)*dist, vx: Math.cos(ang)*4, vy: Math.sin(ang)*4, life: 30, color: '#ffd700', size: 7 });
    }
}

function updateCooldownUI() {
    const skill1CD = document.getElementById('skill1CD');
    const skill2CD = document.getElementById('skill2CD');
    const dashCD = document.getElementById('dashCD');
    
    if (cooldowns.skill1 > 0) {
        skill1CD.classList.add('show');
        skill1CD.textContent = Math.ceil(cooldowns.skill1 / 60);
    } else {
        skill1CD.classList.remove('show');
    }
    
    if (cooldowns.skill2 > 0) {
        skill2CD.classList.add('show');
        skill2CD.textContent = Math.ceil(cooldowns.skill2 / 60);
    } else {
        skill2CD.classList.remove('show');
    }
    
    if (cooldowns.dash > 0) {
        dashCD.classList.add('show');
        dashCD.textContent = Math.ceil(cooldowns.dash / 60);
    } else {
        dashCD.classList.remove('show');
    }
}

function updateEnemies(dt) {
    enemies.forEach(enemy => {
        if (enemy.hitFlash > 0) enemy.hitFlash -= dt * 60;
        
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const dist = Math.hypot(dx, dy);
        
        if (dist > 35) {
            enemy.x += (dx / dist) * enemy.spd * dt * 60;
            enemy.y += (dy / dist) * enemy.spd * dt * 60;
            
            // ìˆ˜ì •ëœ ì  ë°©í–¥ ì„¤ì •
            if (Math.abs(dx) > Math.abs(dy)) {
                enemy.direction = dx < 0 ? 'left' : 'right';
            } else {
                enemy.direction = dy < 0 ? 'up' : 'down';
            }
        }
        
        if (dist < 40 && player.invulnerable <= 0 && enemy.attackCooldown <= 0) {
            const dmg = Math.max(1, enemy.atk - player.def);
            player.hp -= dmg;
            player.invulnerable = 45;
            enemy.attackCooldown = 60;
            player.x -= (dx / dist) * 25;
            player.y -= (dy / dist) * 25;
            
            for (let i = 0; i < 6; i++) {
                particles.push({ x: player.x, y: player.y, vx: (Math.random()-0.5)*6, vy: (Math.random()-0.5)*6, life: 15, color: '#ff0000', size: 4 });
            }
            
            if (player.hp <= 0) gameOver();
        }
        
        if (enemy.attackCooldown > 0) enemy.attackCooldown -= dt * 60;
    });
}

function updateBoss(dt) {
    if (!boss) return;
    if (boss.hitFlash > 0) boss.hitFlash -= dt * 60;
    
    const dx = player.x - boss.x;
    const dy = player.y - boss.y;
    const dist = Math.hypot(dx, dy);
    
    if (dist > 60) {
        boss.x += (dx / dist) * boss.spd * dt * 60;
        boss.y += (dy / dist) * boss.spd * dt * 60;
        
        // ìˆ˜ì •ëœ ë³´ìŠ¤ ë°©í–¥ ì„¤ì •
        if (Math.abs(dx) > Math.abs(dy)) {
            boss.direction = dx < 0 ? 'left' : 'right';
        } else {
            boss.direction = dy < 0 ? 'up' : 'down';
        }
    }
    
    if (dist < 70 && player.invulnerable <= 0 && boss.attackCooldown <= 0) {
        const dmg = Math.max(1, boss.atk - player.def);
        player.hp -= dmg;
        player.invulnerable = 60;
        boss.attackCooldown = 90;
        player.x -= (dx / dist) * 40;
        player.y -= (dy / dist) * 40;
        if (player.hp <= 0) gameOver();
    }
    
    if (boss.specialCooldown <= 0) {
        for (let i = 0; i < 8; i++) {
            const ang = (i/8) * Math.PI * 2;
            projectiles.push({
                x: boss.x, y: boss.y, vx: Math.cos(ang) * 5, vy: Math.sin(ang) * 5,
                damage: boss.atk, size: 15, color: '#e74c3c', owner: 'enemy', life: 120
            });
        }
        boss.specialCooldown = 180;
    }
    
    if (boss.attackCooldown > 0) boss.attackCooldown -= dt * 60;
    if (boss.specialCooldown > 0) boss.specialCooldown -= dt * 60;
}

function damageEnemy(enemy, damage) {
    const dmg = Math.max(1, damage - enemy.def);
    enemy.hp -= dmg;
    enemy.hitFlash = 10;
    
    if (enemy.hp <= 0) {
        const idx = enemies.indexOf(enemy);
        if (idx > -1) enemies.splice(idx, 1);
        kills++;
        gainExp(enemy.exp);
        
        for (let i = 0; i < 10; i++) {
            particles.push({ x: enemy.x, y: enemy.y, vx: (Math.random()-0.5)*8, vy: (Math.random()-0.5)*8, life: 25, color: '#ffd700', size: 5 });
        }
        
        if (Math.random() < 0.15) spawnItem(enemy.x, enemy.y);
        checkWaveComplete();
    }
}

function damageBoss(damage) {
    if (!boss) return;
    const dmg = Math.max(1, damage - boss.def);
    boss.hp -= dmg;
    boss.hitFlash = 10;
    updateBossHP();
    
    if (boss.hp <= 0) {
        kills++;
        gainExp(boss.exp);
        
        for (let i = 0; i < 30; i++) {
            particles.push({ x: boss.x, y: boss.y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 40, color: '#ffd700', size: 8 });
        }
        
        for (let i = 0; i < 3; i++) spawnItem(boss.x + (Math.random()-0.5)*100, boss.y + (Math.random()-0.5)*100);
        
        document.getElementById('bossHp').classList.remove('active');
        boss = null;
        checkWaveComplete();
    }
}

function gainExp(amount) {
    player.exp += amount;
    totalExp += amount;
    while (player.exp >= player.expToNext) levelUp();
    updateHUD();
}

function levelUp() {
    player.exp -= player.expToNext;
    player.level++;
    player.expToNext = Math.floor(100 * Math.pow(1.2, player.level - 1));
    
    const hpUp = 10 + player.level * 2;
    const atkUp = 2 + Math.floor(player.level / 2);
    const defUp = 1 + Math.floor(player.level / 3);
    
    player.maxHp += hpUp;
    player.hp = Math.min(player.maxHp, player.hp + Math.floor(hpUp / 2));
    player.atk += atkUp;
    player.def += defUp;
    
    const lvlup = document.getElementById('levelup');
    lvlup.classList.add('show');
    setTimeout(() => lvlup.classList.remove('show'), 2000);
    
    for (let i = 0; i < 20; i++) {
        const ang = (i/20) * Math.PI * 2;
        particles.push({ x: player.x, y: player.y, vx: Math.cos(ang)*4, vy: Math.sin(ang)*4, life: 30, color: '#ffd700', size: 6 });
    }
}

function spawnItem(x, y) {
    const types = ['heal', 'atkUp', 'exp'];
    items.push({ x, y, type: types[Math.floor(Math.random() * types.length)], life: 600 });
}

function updateItems(dt) {
    items = items.filter(item => {
        item.life -= dt * 60;
        if (Math.hypot(item.x - player.x, item.y - player.y) < 40) {
            if (item.type === 'heal') player.hp = Math.min(player.maxHp, player.hp + Math.floor(player.maxHp * 0.3));
            else if (item.type === 'atkUp') player.atk += 3;
            else if (item.type === 'exp') gainExp(50);
            updateHUD();
            return false;
        }
        return item.life > 0;
    });
}

function updateProjectiles(dt) {
    projectiles = projectiles.filter(p => {
        p.x += p.vx * dt * 60;
        p.y += p.vy * dt * 60;
        p.life -= dt * 60;
        
        if (p.x < 0 || p.x > MAP.width || p.y < 0 || p.y > MAP.height || p.life <= 0) return false;
        
        if (p.owner === 'player') {
            for (let i = enemies.length - 1; i >= 0; i--) {
                if (Math.hypot(p.x - enemies[i].x, p.y - enemies[i].y) < enemies[i].width/2 + p.size) {
                    damageEnemy(enemies[i], p.damage);
                    return false;
                }
            }
            if (boss && Math.hypot(p.x - boss.x, p.y - boss.y) < boss.width/2 + p.size) {
                damageBoss(p.damage);
                return false;
            }
        } else {
            if (player.invulnerable <= 0 && Math.hypot(p.x - player.x, p.y - player.y) < player.width/2 + p.size) {
                const dmg = Math.max(1, p.damage - player.def);
                player.hp -= dmg;
                player.invulnerable = 45;
                if (player.hp <= 0) gameOver();
                return false;
            }
        }
        return true;
    });
}

function updateParticles(dt) {
    particles = particles.filter(p => {
        p.x += p.vx * dt * 60;
        p.y += p.vy * dt * 60;
        p.vx *= 0.95;
        p.vy *= 0.95;
        p.life -= dt * 60;
        return p.life > 0;
    });
}

function updateCamera() {
    const tx = player.x - canvas.width / 2;
    const ty = player.y - canvas.height / 2;
    camera.x += (tx - camera.x) * 0.1;
    camera.y += (ty - camera.y) * 0.1;
    camera.x = Math.max(0, Math.min(MAP.width - canvas.width, camera.x));
    camera.y = Math.max(0, Math.min(MAP.height - canvas.height, camera.y));
}

function updateHUD() {
    document.getElementById('pokemonName').textContent = player.name;
    document.getElementById('pokemonIcon').src = getSprite(player.pokemonId);
    document.getElementById('levelNum').textContent = player.level;
    document.getElementById('hpText').textContent = `${Math.floor(player.hp)}/${player.maxHp}`;
    document.getElementById('hpFill').style.width = Math.max(0, player.hp / player.maxHp * 100) + '%';
    document.getElementById('hpFill').classList.toggle('low', player.hp / player.maxHp < 0.3);
    document.getElementById('expText').textContent = `${player.exp}/${player.expToNext}`;
    document.getElementById('expFill').style.width = (player.exp / player.expToNext * 100) + '%';
    document.getElementById('waveNum').textContent = wave;
    document.getElementById('killCount').textContent = kills;
    document.getElementById('atkStat').textContent = player.atk;
    document.getElementById('defStat').textContent = player.def;
}

function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(-camera.x, -camera.y);
    
    // ë°°ê²½
    const ts = MAP.tileSize;
    const sx = Math.floor(camera.x / ts) * ts;
    const sy = Math.floor(camera.y / ts) * ts;
    for (let x = sx; x < sx + canvas.width + ts*2 && x < MAP.width; x += ts) {
        for (let y = sy; y < sy + canvas.height + ts*2 && y < MAP.height; y += ts) {
            ctx.fillStyle = ((x/ts + y/ts) % 2 === 0) ? '#88c070' : '#78b060';
            ctx.fillRect(x, y, ts, ts);
        }
    }
    ctx.strokeStyle = '#5a8a4a';
    ctx.lineWidth = 6;
    ctx.strokeRect(0, 0, MAP.width, MAP.height);
    
    // ì•„ì´í…œ
    items.forEach(item => {
        ctx.globalAlpha = item.life < 60 ? item.life / 60 : 1;
        ctx.font = '22px Arial';
        ctx.textAlign = 'center';
        const emoji = item.type === 'heal' ? 'â¤ï¸' : item.type === 'atkUp' ? 'âš”ï¸' : 'â­';
        ctx.fillText(emoji, item.x, item.y + Math.sin(Date.now()/200)*5);
    });
    ctx.globalAlpha = 1;
    
    // íŒŒí‹°í´
    particles.forEach(p => {
        ctx.globalAlpha = p.life / 30;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
    });
    ctx.globalAlpha = 1;
    
    // íˆ¬ì‚¬ì²´
    projectiles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 12;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    });
    
    // ì 
    enemies.forEach(e => drawChar(e, true));
    
    // ë³´ìŠ¤
    if (boss) drawChar(boss, true);
    
    // í”Œë ˆì´ì–´
    if (player.invulnerable <= 0 || Math.floor(Date.now()/80) % 2 === 0) {
        drawChar(player, false);
    }
    
    ctx.restore();
}

function drawChar(char, isEnemy) {
    const spriteType = char.direction === 'up' ? 'back' : 'front';
    const img = imageCache[getSprite(char.pokemonId, spriteType)];
    
    // ê·¸ë¦¼ì
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath();
    ctx.ellipse(char.x, char.y + char.height/2 - 5, char.width/3, 10, 0, 0, Math.PI * 2);
    ctx.fill();
    
    if (img) {
        ctx.save();
        if (char.hitFlash > 0) ctx.filter = 'brightness(2)';
        
        // ìˆ˜ì •ëœ ì¢Œìš° ë°©í–¥ ì²˜ë¦¬ - ì˜¤ë¥¸ìª½ì¼ ë•Œ ë°˜ì „
        if (char.direction === 'right') {
            ctx.translate(char.x, char.y);
            ctx.scale(-1, 1);
            ctx.drawImage(img, -char.width/2, -char.height/2, char.width, char.height);
        } else {
            ctx.drawImage(img, char.x - char.width/2, char.y - char.height/2, char.width, char.height);
        }
        ctx.restore();
    } else {
        ctx.fillStyle = isEnemy ? '#e74c3c' : (char.color || '#4CAF50');
        ctx.beginPath();
        ctx.arc(char.x, char.y, char.width/2, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // HPë°” (ì ë§Œ)
    if (isEnemy && char !== boss) {
        const pct = char.hp / char.maxHp;
        ctx.fillStyle = '#333';
        ctx.fillRect(char.x - 25, char.y - char.height/2 - 12, 50, 6);
        ctx.fillStyle = pct > 0.3 ? '#4CAF50' : '#ff6b6b';
        ctx.fillRect(char.x - 25, char.y - char.height/2 - 12, 50 * pct, 6);
    }
}

function gameOver() {
    gameState = 'gameover';
    document.getElementById('finalLevel').textContent = player.level;
    document.getElementById('finalWave').textContent = wave;
    document.getElementById('finalKills').textContent = kills;
    document.getElementById('gameOverScreen').classList.add('active');
}

function pauseGame() {
    if (gameState !== 'playing') return;
    gameState = 'paused';
    document.getElementById('pauseLevel').textContent = player.level;
    document.getElementById('pauseWave').textContent = wave;
    document.getElementById('pauseKills').textContent = kills;
    document.getElementById('pauseScreen').classList.add('active');
}

function resumeGame() {
    gameState = 'playing';
    document.getElementById('pauseScreen').classList.remove('active');
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
}

function changeChar() {
    gameState = 'menu';
    selectedPokemon = null;
    showUI(false);
    document.querySelectorAll('.pokemon-card').forEach(c => c.classList.remove('selected'));
    document.getElementById('startBtn').disabled = true;
    document.getElementById('startBtn').textContent = 'í¬ì¼“ëª¬ì„ ì„ íƒí•˜ì„¸ìš”';
}

function exitGame() {
    changeChar();
}

let lastTime = 0;
function gameLoop(timestamp) {
    if (gameState !== 'playing') return;
    
    const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
    lastTime = timestamp;
    
    updatePlayer(dt);
    updateEnemies(dt);
    updateBoss(dt);
    updateProjectiles(dt);
    updateParticles(dt);
    updateItems(dt);
    updateCamera();
    updateHUD();
    render();
    
    requestAnimationFrame(gameLoop);
}

// ìˆ˜ì •ëœ ì¡°ì´ìŠ¤í‹± ì»¨íŠ¸ë¡¤
function setupJoystick() {
    const container = document.getElementById('joystickContainer');
    const base = document.getElementById('joystickBase');
    const stick = document.getElementById('joystickStick');
    const maxDist = 40;
    
    function handleStart(e) {
        e.preventDefault();
        const touch = e.touches ? e.touches[0] : e;
        const rect = base.getBoundingClientRect();
        joystick.active = true;
        joystick.baseX = rect.left + rect.width / 2;
        joystick.baseY = rect.top + rect.height / 2;
        if (e.touches) joystick.touchId = e.touches[0].identifier;
        handleMove(e);
    }
    
    function handleMove(e) {
        if (!joystick.active) return;
        e.preventDefault();
        
        let touch;
        if (e.touches) {
            for (let t of e.touches) {
                if (t.identifier === joystick.touchId) { touch = t; break; }
            }
            if (!touch) return;
        } else {
            touch = e;
        }
        
        const dx = touch.clientX - joystick.baseX;
        const dy = touch.clientY - joystick.baseY;
        const dist = Math.hypot(dx, dy);
        const clampedDist = Math.min(dist, maxDist);
        const angle = Math.atan2(dy, dx);
        
        const stickX = Math.cos(angle) * clampedDist;
        const stickY = Math.sin(angle) * clampedDist;
        
        stick.style.left = `calc(50% + ${stickX}px)`;
        stick.style.top = `calc(50% + ${stickY}px)`;
        
        input.moveX = clampedDist > 5 ? stickX / maxDist : 0;
        input.moveY = clampedDist > 5 ? stickY / maxDist : 0;
    }
    
    function handleEnd(e) {
        if (e.touches && e.touches.length > 0) {
            let found = false;
            for (let t of e.touches) {
                if (t.identifier === joystick.touchId) { found = true; break; }
            }
            if (found) return;
        }
        
        joystick.active = false;
        joystick.touchId = null;
        stick.style.left = '50%';
        stick.style.top = '50%';
        input.moveX = 0;
        input.moveY = 0;
    }
    
    container.addEventListener('touchstart', handleStart, { passive: false });
    container.addEventListener('touchmove', handleMove, { passive: false });
    container.addEventListener('touchend', handleEnd);
    container.addEventListener('touchcancel', handleEnd);
    
    container.addEventListener('mousedown', handleStart);
    document.addEventListener('mousemove', (e) => { if (joystick.active) handleMove(e); });
    document.addEventListener('mouseup', handleEnd);
}

function setupButtons() {
    const btnAttack = document.getElementById('btnAttack');
    const btnSkill1 = document.getElementById('btnSkill1');
    const btnSkill2 = document.getElementById('btnSkill2');
    const btnDash = document.getElementById('btnDash');
    
    function addBtnEvents(btn, key) {
        btn.addEventListener('touchstart', e => { e.preventDefault(); input[key] = true; }, { passive: false });
        btn.addEventListener('touchend', e => { e.preventDefault(); input[key] = false; });
        btn.addEventListener('mousedown', () => input[key] = true);
        btn.addEventListener('mouseup', () => input[key] = false);
        btn.addEventListener('mouseleave', () => input[key] = false);
    }
    
    addBtnEvents(btnAttack, 'attack');
    addBtnEvents(btnSkill1, 'skill1');
    addBtnEvents(btnSkill2, 'skill2');
    addBtnEvents(btnDash, 'dash');
    
    // ìˆ˜ì •ëœ í‚¤ë³´ë“œ ì´ë²¤íŠ¸ - keyState ì‚¬ìš©
    document.addEventListener('keydown', e => {
        if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keyState.up = true;
        if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keyState.down = true;
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keyState.left = true;
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keyState.right = true;
        if (e.key === ' ' || e.key === 'z' || e.key === 'Z') input.attack = true;
        if (e.key === 'x' || e.key === 'X') input.skill1 = true;
        if (e.key === 'c' || e.key === 'C') input.skill2 = true;
        if (e.key === 'Shift') input.dash = true;
        if (e.key === 'Escape') { if (gameState === 'playing') pauseGame(); else if (gameState === 'paused') resumeGame(); }
    });
    
    document.addEventListener('keyup', e => {
        if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keyState.up = false;
        if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keyState.down = false;
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keyState.left = false;
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keyState.right = false;
        if (e.key === ' ' || e.key === 'z' || e.key === 'Z') input.attack = false;
        if (e.key === 'x' || e.key === 'X') input.skill1 = false;
        if (e.key === 'c' || e.key === 'C') input.skill2 = false;
        if (e.key === 'Shift') input.dash = false;
    });
}

function setupUIButtons() {
    document.getElementById('startBtn').onclick = startGame;
    document.getElementById('menuBtn').onclick = pauseGame;
    document.getElementById('resumeBtn').onclick = resumeGame;
    document.getElementById('changeCharBtn').onclick = changeChar;
    document.getElementById('exitBtn').onclick = exitGame;
    document.getElementById('restartBtn').onclick = startGame;
    document.getElementById('changeCharBtn2').onclick = changeChar;
    document.getElementById('exitBtn2').onclick = exitGame;
}

async function init() {
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    await preloadImages();
    
    initPokemonSelection();
    setupJoystick();
    setupButtons();
    setupUIButtons();
    
    console.log('Game Ready!');
}

init();
</script>
</body>
</html>
