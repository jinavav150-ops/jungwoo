<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Ìè¨ÏºìÎ™¨ Î°úÍ∑∏ÎùºÏù¥ÌÅ¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        body {
            font-family: 'Malgun Gothic', sans-serif;
            background: #000;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        #gameCanvas {
            display: block;
            background: #2d2d44;
            touch-action: none;
            image-rendering: pixelated;
        }

        /* UI Ïò§Î≤ÑÎ†àÏù¥ */
        .hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 10;
        }

        .hud-box {
            background: rgba(0,0,0,0.85);
            padding: 12px 16px;
            border-radius: 10px;
            border: 2px solid #ffd700;
            color: white;
            font-size: 14px;
            font-weight: bold;
        }

        .hp-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .hp-bar {
            width: 200px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #555;
        }

        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 11px;
        }

        .hp-fill.low {
            background: linear-gradient(90deg, #ff6b6b, #ee5a6f);
        }

        .room-info {
            text-align: right;
        }

        /* Ï°∞Ïù¥Ïä§Ìã± */
        .joystick {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 140px;
            height: 140px;
            z-index: 100;
            pointer-events: auto;
        }

        .joystick-base {
            width: 100%;
            height: 100%;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.3);
            position: relative;
        }

        .joystick-stick {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255,215,0,0.7);
            border-radius: 50%;
            border: 3px solid #ffd700;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        /* Î≤ÑÌäº */
        .action-buttons {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 100;
            pointer-events: auto;
        }

        .btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 3px solid;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
            position: relative;
            transition: transform 0.1s;
        }

        .btn:active {
            transform: scale(0.9);
        }

        .btn-attack {
            background: rgba(255,107,107,0.4);
            border-color: #ff6b6b;
        }

        .btn-skill {
            background: rgba(155,89,182,0.4);
            border-color: #9b59b6;
        }

        .btn-dash {
            background: rgba(78,205,196,0.4);
            border-color: #4ecdc4;
            width: 60px;
            height: 60px;
            font-size: 28px;
        }

        .cooldown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            font-weight: bold;
        }

        /* ÏãúÏûë ÌôîÎ©¥ */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 1000;
            padding: 20px;
        }

        .screen.hidden {
            display: none;
        }

        h1 {
            font-size: 2.8em;
            color: #ffd700;
            text-shadow: 3px 3px 0 #000, -1px -1px 0 #000;
            margin-bottom: 30px;
        }

        .pokemon-select {
            display: flex;
            gap: 20px;
            margin: 30px 0;
        }

        .pokemon-card {
            background: rgba(255,255,255,0.9);
            padding: 20px;
            border-radius: 15px;
            cursor: pointer;
            border: 4px solid transparent;
            transition: all 0.3s;
        }

        .pokemon-card.selected {
            border-color: #ffd700;
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255,215,0,0.8);
        }

        .pokemon-preview {
            width: 100px;
            height: 100px;
            margin: 0 auto 10px;
        }

        .pokemon-name {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }

        .pokemon-stats {
            font-size: 12px;
            color: #666;
        }

        .start-btn {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #333;
            border: 3px solid #ff6b00;
            padding: 15px 50px;
            font-size: 24px;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 20px;
        }

        .start-btn:disabled {
            background: #666;
            border-color: #444;
            cursor: not-allowed;
        }

        /* Í≤åÏûÑÏò§Î≤Ñ ÌôîÎ©¥ */
        .game-over {
            background: rgba(0,0,0,0.95);
        }

        .game-over h1 {
            color: #e74c3c;
        }

        .stats-box {
            background: rgba(255,255,255,0.1);
            padding: 20px 40px;
            border-radius: 15px;
            margin: 20px 0;
            border: 2px solid #ffd700;
        }

        .stat-line {
            color: white;
            font-size: 18px;
            margin: 10px 0;
        }

        /* Î≥¥ÏÉÅ ÏÑ†ÌÉù ÌôîÎ©¥ */
        .upgrade-select {
            background: rgba(0,0,0,0.95);
        }

        .upgrade-cards {
            display: flex;
            gap: 20px;
            margin: 30px 0;
        }

        .upgrade-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            border-radius: 15px;
            width: 200px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s;
        }

        .upgrade-card:hover {
            transform: translateY(-10px);
            border-color: #ffd700;
        }

        .upgrade-name {
            color: #ffd700;
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .upgrade-desc {
            color: white;
            font-size: 14px;
        }

        .rarity {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 10px;
            font-size: 11px;
            margin-top: 10px;
        }

        .rarity-common { background: #95a5a6; }
        .rarity-uncommon { background: #2ecc71; }
        .rarity-rare { background: #3498db; }
        .rarity-epic { background: #9b59b6; }

        /* ÎØ∏ÎãàÎßµ */
        .minimap {
            position: absolute;
            top: 90px;
            right: 10px;
            width: 150px;
            height: 100px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #ffd700;
            border-radius: 8px;
            padding: 5px;
            z-index: 10;
        }

        .minimap-room {
            width: 25px;
            height: 25px;
            background: #555;
            border: 1px solid #888;
            display: inline-block;
            margin: 2px;
        }

        .minimap-room.current {
            background: #ffd700;
        }

        .minimap-room.cleared {
            background: #4CAF50;
        }

        .minimap-room.boss {
            background: #e74c3c;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div class="hud">
        <div class="hud-box">
            <div class="hp-container">
                <div style="color: #ffd700; font-size: 16px;" id="pokemonName">ÌîºÏπ¥Ï∏Ñ</div>
                <div class="hp-bar">
                    <div class="hp-fill" id="hpBar" style="width: 100%;">100/100</div>
                </div>
            </div>
        </div>
        <div class="hud-box room-info">
            <div style="color: #4ecdc4;" id="roomType">ÏãúÏûëÎ∞©</div>
            <div style="color: #ffd700; margin-top: 5px;">üí∞ <span id="coinCount">0</span></div>
        </div>
    </div>

    <!-- ÎØ∏ÎãàÎßµ -->
    <div class="minimap" id="minimap"></div>

    <!-- Ï°∞Ïù¥Ïä§Ìã± -->
    <div class="joystick" id="joystick">
        <div class="joystick-base">
            <div class="joystick-stick" id="joystickStick"></div>
        </div>
    </div>

    <!-- Î≤ÑÌäº -->
    <div class="action-buttons">
        <div class="btn btn-dash" id="dashBtn">
            üí®
            <div class="cooldown-overlay hidden" id="dashCooldown">0</div>
        </div>
        <div class="btn btn-skill" id="skillBtn">
            ‚ö°
            <div class="cooldown-overlay hidden" id="skillCooldown">0</div>
        </div>
        <div class="btn btn-attack" id="attackBtn">‚öîÔ∏è</div>
    </div>

    <!-- ÏãúÏûë ÌôîÎ©¥ -->
    <div class="screen" id="startScreen">
        <h1>‚ö° Ìè¨ÏºìÎ™¨ Î°úÍ∑∏ÎùºÏù¥ÌÅ¨ ‚ö°</h1>
        <p style="color: white; font-size: 18px;">Ìè¨ÏºìÎ™¨ÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî</p>

        <div class="pokemon-select">
            <div class="pokemon-card" data-pokemon="pikachu">
                <canvas class="pokemon-preview" width="100" height="100"></canvas>
                <div class="pokemon-name">ÌîºÏπ¥Ï∏Ñ</div>
                <div class="pokemon-stats">HP: 100 | Îπ†Î•∏ Í≥µÍ≤©</div>
            </div>
        </div>

        <button class="start-btn" id="startBtn">Î™®Ìóò ÏãúÏûë!</button>
    </div>

    <!-- Î≥¥ÏÉÅ ÏÑ†ÌÉù ÌôîÎ©¥ -->
    <div class="screen upgrade-select hidden" id="upgradeScreen">
        <h1>Í∞ïÌôî ÏÑ†ÌÉù</h1>
        <div class="upgrade-cards" id="upgradeCards"></div>
    </div>

    <!-- Í≤åÏûÑÏò§Î≤Ñ ÌôîÎ©¥ -->
    <div class="screen game-over hidden" id="gameOverScreen">
        <h1>Í≤åÏûÑ Ïò§Î≤Ñ</h1>
        <div class="stats-box">
            <div class="stat-line">ÎèÑÎã¨ Î∞©: <span id="finalRoom">0</span></div>
            <div class="stat-line">Ï≤òÏπò: <span id="finalKills">0</span></div>
            <div class="stat-line">ÏΩîÏù∏: <span id="finalCoins">0</span></div>
        </div>
        <button class="start-btn" id="restartBtn">Îã§Ïãú ÏãúÏûë</button>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, set, push, get, query, orderByChild, limitToLast } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        const firebaseConfig = {
            apiKey: "AIzaSyAj0M7AuQnOlnWV1ZDcuY0Ij9eOV7SRUlg",
            authDomain: "free-96bc0.firebaseapp.com",
            databaseURL: "https://free-96bc0-default-rtdb.firebaseio.com",
            projectId: "free-96bc0",
            storageBucket: "free-96bc0.firebasestorage.app",
            messagingSenderId: "131017218548",
            appId: "1:131017218548:web:55ee3cb626695ede9841a1"
        };

        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        window.saveScore = async function(roomReached, kills, coins) {
            try {
                const scoresRef = ref(database, 'pokemon-roguelike/scores');
                const newScoreRef = push(scoresRef);
                await set(newScoreRef, {
                    roomReached,
                    kills,
                    coins,
                    timestamp: Date.now()
                });
            } catch (error) {
                console.error('Ï†ÄÏû• Ïã§Ìå®:', error);
            }
        };
    </script>

    <script>
        // Í≤åÏûÑ ÏÑ§Ï†ï
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Í≤åÏûÑ ÏÉÅÌÉú
        let gameState = 'menu'; // menu, playing, paused, gameover
        let player = null;
        let enemies = [];
        let projectiles = [];
        let enemyProjectiles = [];
        let particles = [];
        let coins = [];
        let currentRoom = 0;
        let rooms = [];
        let totalKills = 0;
        let totalCoins = 0;

        // Ï°∞Ïù¥Ïä§Ìã±
        let joystickActive = false;
        let joystickVector = { x: 0, y: 0 };

        // Ïø®ÌÉÄÏûÑ
        let attackCooldown = 0;
        let skillCooldown = 0;
        let dashCooldown = 0;

        // ÌîºÏπ¥Ï∏Ñ Í∑∏Î¶¨Í∏∞
        const pikachuPreview = document.querySelector('.pokemon-preview');
        const pctx = pikachuPreview.getContext('2d');
        drawPikachu(pctx, 50, 50, 30);

        function drawPikachu(ctx, x, y, size) {
            // Í∑Ä ÏôºÏ™Ω
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.moveTo(x - size * 0.3, y - size * 0.3);
            ctx.lineTo(x - size * 0.5, y - size * 0.8);
            ctx.lineTo(x - size * 0.15, y - size * 0.4);
            ctx.fill();

            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.moveTo(x - size * 0.45, y - size * 0.75);
            ctx.lineTo(x - size * 0.52, y - size * 0.82);
            ctx.lineTo(x - size * 0.35, y - size * 0.68);
            ctx.fill();

            // Í∑Ä Ïò§Î•∏Ï™Ω
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.moveTo(x + size * 0.3, y - size * 0.3);
            ctx.lineTo(x + size * 0.5, y - size * 0.8);
            ctx.lineTo(x + size * 0.15, y - size * 0.4);
            ctx.fill();

            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.moveTo(x + size * 0.45, y - size * 0.75);
            ctx.lineTo(x + size * 0.52, y - size * 0.82);
            ctx.lineTo(x + size * 0.35, y - size * 0.68);
            ctx.fill();

            // Î®∏Î¶¨
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x, y - size * 0.2, size * 0.35, 0, Math.PI * 2);
            ctx.fill();

            // Î™∏
            ctx.beginPath();
            ctx.ellipse(x, y + size * 0.15, size * 0.3, size * 0.35, 0, 0, Math.PI * 2);
            ctx.fill();

            // Îàà
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - size * 0.15, y - size * 0.25, size * 0.08, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.15, y - size * 0.25, size * 0.08, 0, Math.PI * 2);
            ctx.fill();

            // Î≥º
            ctx.fillStyle = '#FF6B6B';
            ctx.beginPath();
            ctx.arc(x - size * 0.25, y - size * 0.15, size * 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.25, y - size * 0.15, size * 0.1, 0, Math.PI * 2);
            ctx.fill();
        }

        // Ìè¨ÏºìÎ™¨ ÏÑ†ÌÉù
        document.querySelector('.pokemon-card').addEventListener('click', function() {
            this.classList.add('selected');
        });

        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', () => {
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('startScreen').classList.remove('hidden');
        });

        // Ï°∞Ïù¥Ïä§Ìã± Ïª®Ìä∏Î°§
        const joystick = document.getElementById('joystick');
        const joystickStick = document.getElementById('joystickStick');

        joystick.addEventListener('touchstart', handleJoystickStart);
        joystick.addEventListener('touchmove', handleJoystickMove);
        joystick.addEventListener('touchend', handleJoystickEnd);

        function handleJoystickStart(e) {
            e.preventDefault();
            joystickActive = true;
        }

        function handleJoystickMove(e) {
            e.preventDefault();
            if (!joystickActive) return;

            const touch = e.touches[0];
            const rect = joystick.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            let dx = touch.clientX - centerX;
            let dy = touch.clientY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDistance = 45;

            if (distance > maxDistance) {
                dx = (dx / distance) * maxDistance;
                dy = (dy / distance) * maxDistance;
            }

            joystickStick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            joystickVector = {
                x: dx / maxDistance,
                y: dy / maxDistance
            };
        }

        function handleJoystickEnd(e) {
            e.preventDefault();
            joystickActive = false;
            joystickStick.style.transform = 'translate(-50%, -50%)';
            joystickVector = { x: 0, y: 0 };
        }

        // Î≤ÑÌäº Ïù¥Î≤§Ìä∏
        document.getElementById('attackBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            performAttack();
        });

        document.getElementById('skillBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            performSkill();
        });

        document.getElementById('dashBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            performDash();
        });

        // Í≤åÏûÑ ÏãúÏûë
        function startGame() {
            player = {
                x: canvas.width / 2,
                y: canvas.height / 2,
                size: 25,
                hp: 100,
                maxHp: 100,
                speed: 300,
                attackDamage: 20,
                attackSpeed: 1.0,
                projectileSpeed: 500,
                invulnerable: 0,
                isDashing: false,
                upgrades: []
            };

            // ÎçòÏ†Ñ ÏÉùÏÑ± (5Í∞ú Î∞©)
            rooms = [
                { type: 'start', cleared: false },
                { type: 'normal', cleared: false },
                { type: 'normal', cleared: false },
                { type: 'treasure', cleared: false },
                { type: 'boss', cleared: false }
            ];

            currentRoom = 0;
            totalKills = 0;
            totalCoins = 0;
            enemies = [];
            projectiles = [];
            enemyProjectiles = [];
            particles = [];
            coins = [];

            updateMinimap();
            spawnEnemies();
            updateUI();

            gameState = 'playing';
            document.getElementById('startScreen').classList.add('hidden');
            gameLoop();
        }

        // Ï†Å ÏÉùÏÑ±
        function spawnEnemies() {
            const room = rooms[currentRoom];
            if (room.type === 'start') {
                // ÏãúÏûëÎ∞©ÏùÄ Ï†Å ÏóÜÏùå
                room.cleared = true;
                return;
            }

            let count = room.type === 'boss' ? 1 : 3 + currentRoom;
            let isBoss = room.type === 'boss';

            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    const side = Math.floor(Math.random() * 4);
                    let x, y;
                    const margin = 50;

                    switch(side) {
                        case 0: x = Math.random() * canvas.width; y = -margin; break;
                        case 1: x = canvas.width + margin; y = Math.random() * canvas.height; break;
                        case 2: x = Math.random() * canvas.width; y = canvas.height + margin; break;
                        case 3: x = -margin; y = Math.random() * canvas.height; break;
                    }

                    enemies.push({
                        x, y,
                        size: isBoss ? 40 : 20,
                        hp: isBoss ? 200 : 30 + currentRoom * 10,
                        maxHp: isBoss ? 200 : 30 + currentRoom * 10,
                        speed: isBoss ? 80 : 120,
                        damage: isBoss ? 20 : 10,
                        lastAttack: 0,
                        attackCooldown: isBoss ? 1500 : 2000,
                        isBoss: isBoss,
                        color: isBoss ? '#e74c3c' : '#8e44ad'
                    });
                }, i * 500);
            }
        }

        // Í≥µÍ≤©
        function performAttack() {
            if (attackCooldown > 0) return;

            const nearestEnemy = findNearestEnemy();
            if (!nearestEnemy) return;

            const dx = nearestEnemy.x - player.x;
            const dy = nearestEnemy.y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            projectiles.push({
                x: player.x,
                y: player.y,
                vx: (dx / dist) * player.projectileSpeed,
                vy: (dy / dist) * player.projectileSpeed,
                damage: player.attackDamage,
                size: 8,
                color: '#FFFF00',
                penetration: 0
            });

            attackCooldown = 1000 / player.attackSpeed;
        }

        // Ïä§ÌÇ¨ (10ÎßåÎ≥ºÌä∏)
        function performSkill() {
            if (skillCooldown > 0) return;

            const nearestEnemy = findNearestEnemy();
            if (!nearestEnemy) return;

            const dx = nearestEnemy.x - player.x;
            const dy = nearestEnemy.y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            projectiles.push({
                x: player.x,
                y: player.y,
                vx: (dx / dist) * 600,
                vy: (dy / dist) * 600,
                damage: 80,
                size: 20,
                color: '#FFD700',
                penetration: 1,
                chain: 2
            });

            skillCooldown = 5000;
            createSkillEffect(player.x, player.y, 150);
        }

        // ÎåÄÏãú
        function performDash() {
            if (dashCooldown > 0 || !joystickActive) return;

            player.isDashing = true;
            player.invulnerable = true;
            const dashSpeed = 800;
            const duration = 300;

            const vx = joystickVector.x * dashSpeed;
            const vy = joystickVector.y * dashSpeed;

            const startTime = Date.now();
            const dashInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                if (elapsed >= duration) {
                    clearInterval(dashInterval);
                    player.isDashing = false;
                    player.invulnerable = false;
                    return;
                }

                player.x += vx * (1/60);
                player.y += vy * (1/60);

                // Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨
                player.x = Math.max(player.size, Math.min(canvas.width - player.size, player.x));
                player.y = Math.max(player.size, Math.min(canvas.height - player.size, player.y));

                // ÏûîÏÉÅ Ìö®Í≥º
                particles.push({
                    x: player.x,
                    y: player.y,
                    size: player.size,
                    color: '#FFD700',
                    alpha: 0.5,
                    life: 10
                });
            }, 16);

            dashCooldown = 2000;
        }

        function findNearestEnemy() {
            let nearest = null;
            let minDist = Infinity;

            enemies.forEach(enemy => {
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < minDist) {
                    minDist = dist;
                    nearest = enemy;
                }
            });

            return nearest;
        }

        function createSkillEffect(x, y, radius) {
            for (let i = 0; i < 30; i++) {
                const angle = (Math.PI * 2 / 30) * i;
                particles.push({
                    x: x + Math.cos(angle) * radius,
                    y: y + Math.sin(angle) * radius,
                    vx: Math.cos(angle) * 3,
                    vy: Math.sin(angle) * 3,
                    size: 5,
                    color: '#FFD700',
                    alpha: 1,
                    life: 20
                });
            }
        }

        // Í≤åÏûÑ Î£®ÌîÑ
        function gameLoop() {
            if (gameState !== 'playing') return;

            const deltaTime = 1/60;
            update(deltaTime);
            render();
            requestAnimationFrame(gameLoop);
        }

        function update(dt) {
            // Ïø®ÌÉÄÏûÑ Í∞±Ïã†
            if (attackCooldown > 0) attackCooldown -= 16;
            if (skillCooldown > 0) {
                skillCooldown -= 16;
                document.getElementById('skillCooldown').textContent = Math.ceil(skillCooldown / 1000);
                document.getElementById('skillCooldown').classList.remove('hidden');
            } else {
                document.getElementById('skillCooldown').classList.add('hidden');
            }
            if (dashCooldown > 0) {
                dashCooldown -= 16;
                document.getElementById('dashCooldown').textContent = Math.ceil(dashCooldown / 1000);
                document.getElementById('dashCooldown').classList.remove('hidden');
            } else {
                document.getElementById('dashCooldown').classList.add('hidden');
            }

            // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Îèô
            if (joystickActive && !player.isDashing) {
                player.x += joystickVector.x * player.speed * dt;
                player.y += joystickVector.y * player.speed * dt;

                player.x = Math.max(player.size, Math.min(canvas.width - player.size, player.x));
                player.y = Math.max(player.size, Math.min(canvas.height - player.size, player.y));
            }

            if (player.invulnerable > 0) player.invulnerable--;

            // Ìà¨ÏÇ¨Ï≤¥ ÏóÖÎç∞Ïù¥Ìä∏
            projectiles = projectiles.filter(proj => {
                proj.x += proj.vx * dt;
                proj.y += proj.vy * dt;

                if (proj.x < 0 || proj.x > canvas.width || proj.y < 0 || proj.y > canvas.height) {
                    return false;
                }

                // Ï†ÅÍ≥º Ï∂©Îèå
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    const dx = proj.x - enemy.x;
                    const dy = proj.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < enemy.size + proj.size) {
                        enemy.hp -= proj.damage;
                        createParticles(enemy.x, enemy.y, enemy.color, 8);

                        if (enemy.hp <= 0) {
                            killEnemy(enemy, i);
                        }

                        if (proj.penetration > 0) {
                            proj.penetration--;
                            return true;
                        }

                        return false;
                    }
                }

                return true;
            });

            // Ï†Å ÏóÖÎç∞Ïù¥Ìä∏
            enemies.forEach(enemy => {
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 0) {
                    enemy.x += (dx / dist) * enemy.speed * dt;
                    enemy.y += (dy / dist) * enemy.speed * dt;
                }

                // ÌîåÎ†àÏù¥Ïñ¥ Ï∂©Îèå
                if (dist < player.size + enemy.size && !player.invulnerable) {
                    player.hp -= enemy.damage;
                    player.invulnerable = 30;
                    updateUI();

                    if (player.hp <= 0) {
                        gameOver();
                    }
                }

                // Ï†Å Í≥µÍ≤©
                if (Date.now() - enemy.lastAttack > enemy.attackCooldown && dist < 300) {
                    enemyProjectiles.push({
                        x: enemy.x,
                        y: enemy.y,
                        vx: (dx / dist) * 300,
                        vy: (dy / dist) * 300,
                        damage: enemy.damage,
                        size: 6,
                        color: enemy.color
                    });
                    enemy.lastAttack = Date.now();
                }
            });

            // Ï†Å Ìà¨ÏÇ¨Ï≤¥
            enemyProjectiles = enemyProjectiles.filter(proj => {
                proj.x += proj.vx * dt;
                proj.y += proj.vy * dt;

                if (proj.x < 0 || proj.x > canvas.width || proj.y < 0 || proj.y > canvas.height) {
                    return false;
                }

                const dx = proj.x - player.x;
                const dy = proj.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < player.size + proj.size && !player.invulnerable) {
                    player.hp -= proj.damage;
                    player.invulnerable = 30;
                    updateUI();

                    if (player.hp <= 0) {
                        gameOver();
                    }

                    return false;
                }

                return true;
            });

            // ÌååÌã∞ÌÅ¥
            particles = particles.filter(p => {
                if (p.vx !== undefined) {
                    p.x += p.vx;
                    p.y += p.vy;
                }
                p.life--;
                p.alpha = p.life / 20;
                return p.life > 0;
            });

            // ÏΩîÏù∏
            coins.forEach(coin => {
                const dx = player.x - coin.x;
                const dy = player.y - coin.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 100) {
                    coin.x += (dx / dist) * 5;
                    coin.y += (dy / dist) * 5;
                }

                if (dist < player.size + coin.size) {
                    totalCoins += coin.value;
                    updateUI();
                    coins.splice(coins.indexOf(coin), 1);
                }
            });

            // Î∞© ÌÅ¥Î¶¨Ïñ¥ Ï≤¥ÌÅ¨
            if (enemies.length === 0 && !rooms[currentRoom].cleared) {
                rooms[currentRoom].cleared = true;
                updateMinimap();

                if (currentRoom < rooms.length - 1) {
                    if (rooms[currentRoom].type === 'treasure') {
                        showUpgradeScreen();
                    } else {
                        setTimeout(() => {
                            currentRoom++;
                            player.x = canvas.width / 2;
                            player.y = canvas.height / 2;
                            updateUI();
                            spawnEnemies();
                        }, 2000);
                    }
                } else {
                    // Í≤åÏûÑ ÌÅ¥Î¶¨Ïñ¥!
                    setTimeout(() => {
                        alert('ÎçòÏ†Ñ ÌÅ¥Î¶¨Ïñ¥!');
                        gameOver();
                    }, 2000);
                }
            }
        }

        function killEnemy(enemy, index) {
            totalKills++;
            updateUI();

            // ÏΩîÏù∏ ÎìúÎ°≠
            const coinCount = enemy.isBoss ? 10 : 3;
            for (let i = 0; i < coinCount; i++) {
                coins.push({
                    x: enemy.x + (Math.random() - 0.5) * 30,
                    y: enemy.y + (Math.random() - 0.5) * 30,
                    size: 8,
                    value: enemy.isBoss ? 10 : 3
                });
            }

            createParticles(enemy.x, enemy.y, enemy.color, 20);
            enemies.splice(index, 1);
        }

        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    size: 3 + Math.random() * 3,
                    color,
                    alpha: 1,
                    life: 20
                });
            }
        }

        function render() {
            // Î∞∞Í≤Ω
            ctx.fillStyle = '#2d2d44';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Í∑∏Î¶¨Îìú
            ctx.strokeStyle = 'rgba(255,255,255,0.05)';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i < canvas.height; i += 50) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }

            // ÌååÌã∞ÌÅ¥
            particles.forEach(p => {
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // ÏΩîÏù∏
            coins.forEach(coin => {
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(coin.x, coin.y, coin.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#FFA500';
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // Ìà¨ÏÇ¨Ï≤¥
            projectiles.forEach(proj => {
                ctx.fillStyle = proj.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = proj.color;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, proj.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });

            enemyProjectiles.forEach(proj => {
                ctx.fillStyle = proj.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = proj.color;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, proj.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });

            // Ï†Å
            enemies.forEach(enemy => {
                // Í∑∏Î¶ºÏûê
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(enemy.x, enemy.y + enemy.size + 3, enemy.size * 0.8, enemy.size * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Î™∏Ï≤¥
                ctx.fillStyle = enemy.color;
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
                ctx.fill();

                if (enemy.isBoss) {
                    ctx.fillStyle = '#FFF';
                    ctx.font = '30px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üëπ', enemy.x, enemy.y);
                }

                // HP Î∞î
                const barWidth = enemy.size * 2.5;
                const hpPercent = enemy.hp / enemy.maxHp;
                ctx.fillStyle = '#333';
                ctx.fillRect(enemy.x - barWidth / 2, enemy.y - enemy.size - 15, barWidth, 5);
                ctx.fillStyle = hpPercent > 0.5 ? '#4CAF50' : '#e74c3c';
                ctx.fillRect(enemy.x - barWidth / 2, enemy.y - enemy.size - 15, barWidth * hpPercent, 5);
            });

            // ÌîåÎ†àÏù¥Ïñ¥
            if (!player.invulnerable || Math.floor(Date.now() / 100) % 2 === 0) {
                // Í∑∏Î¶ºÏûê
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(player.x, player.y + player.size + 5, player.size * 0.7, player.size * 0.25, 0, 0, Math.PI * 2);
                ctx.fill();

                drawPikachu(ctx, player.x, player.y, player.size);
            }
        }

        function updateUI() {
            const hpPercent = (player.hp / player.maxHp) * 100;
            const hpBar = document.getElementById('hpBar');
            hpBar.style.width = Math.max(0, hpPercent) + '%';
            hpBar.textContent = `${Math.max(0, Math.floor(player.hp))}/${player.maxHp}`;

            if (hpPercent < 30) {
                hpBar.classList.add('low');
            } else {
                hpBar.classList.remove('low');
            }

            const roomType = rooms[currentRoom].type;
            const typeNames = {
                start: 'ÏãúÏûëÎ∞©',
                normal: 'Ï†ÑÌà¨Î∞©',
                treasure: 'Î≥¥Î¨ºÎ∞©',
                boss: 'Î≥¥Ïä§Î∞©'
            };
            document.getElementById('roomType').textContent = `${currentRoom + 1}/5 - ${typeNames[roomType]}`;
            document.getElementById('coinCount').textContent = totalCoins;
        }

        function updateMinimap() {
            const minimap = document.getElementById('minimap');
            minimap.innerHTML = '';

            rooms.forEach((room, index) => {
                const div = document.createElement('div');
                div.className = 'minimap-room';
                if (index === currentRoom) div.classList.add('current');
                if (room.cleared) div.classList.add('cleared');
                if (room.type === 'boss') div.classList.add('boss');
                minimap.appendChild(div);
            });
        }

        function showUpgradeScreen() {
            gameState = 'paused';

            const upgrades = [
                { name: 'Í≥µÍ≤©Î†• Ï¶ùÍ∞Ä', desc: '+15% Í≥µÍ≤©Î†•', effect: () => player.attackDamage *= 1.15, rarity: 'common' },
                { name: 'Í≥µÍ≤© ÏÜçÎèÑ', desc: '+20% Í≥µÍ≤© ÏÜçÎèÑ', effect: () => player.attackSpeed *= 1.2, rarity: 'common' },
                { name: 'ÏµúÎåÄ HP', desc: '+20 ÏµúÎåÄ HP', effect: () => { player.maxHp += 20; player.hp += 20; }, rarity: 'common' },
                { name: 'Ïù¥Îèô ÏÜçÎèÑ', desc: '+30 Ïù¥Îèô ÏÜçÎèÑ', effect: () => player.speed += 30, rarity: 'common' },
                { name: 'Îã§Ï§ë Î∞úÏÇ¨', desc: '+1 Î∞úÏÇ¨Ï≤¥', effect: () => player.attackDamage *= 0.9, rarity: 'rare' }
            ];

            const selected = [];
            while (selected.length < 3) {
                const upgrade = upgrades[Math.floor(Math.random() * upgrades.length)];
                if (!selected.includes(upgrade)) selected.push(upgrade);
            }

            const container = document.getElementById('upgradeCards');
            container.innerHTML = '';

            selected.forEach(upgrade => {
                const card = document.createElement('div');
                card.className = 'upgrade-card';
                card.innerHTML = `
                    <div class="upgrade-name">${upgrade.name}</div>
                    <div class="upgrade-desc">${upgrade.desc}</div>
                    <span class="rarity rarity-${upgrade.rarity}">${upgrade.rarity.toUpperCase()}</span>
                `;
                card.addEventListener('click', () => {
                    upgrade.effect();
                    player.upgrades.push(upgrade);
                    document.getElementById('upgradeScreen').classList.add('hidden');
                    gameState = 'playing';

                    currentRoom++;
                    player.x = canvas.width / 2;
                    player.y = canvas.height / 2;
                    updateUI();
                    spawnEnemies();
                });
                container.appendChild(card);
            });

            document.getElementById('upgradeScreen').classList.remove('hidden');
        }

        async function gameOver() {
            gameState = 'gameover';

            await window.saveScore(currentRoom + 1, totalKills, totalCoins);

            document.getElementById('finalRoom').textContent = `${currentRoom + 1}/5`;
            document.getElementById('finalKills').textContent = totalKills;
            document.getElementById('finalCoins').textContent = totalCoins;
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }
    </script>
</body>
</html>
